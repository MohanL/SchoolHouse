{
  "name": "Davis Academy",
  "tagline": "A RoR Project demonstrating various model relationships, nested forms, nested resources, authentication (Devise/OAuth), and authorization (Pundit)",
  "body": "###Overview###\r\nOne of Rails' greatest strengths is that it allows the developer to quickly build and reference models.  In this demonstration, we have a base `User` class which `has_many :students` and in turn `has_many :student_classes, through: :students` - the `students` table serving as a join table.  Additionally, a `User` may have many `supplies` through `student_classes` - this time with the `student_classes` table filling the role as join table.  These basic associations allow the normal (non-Admin) user to view her students, the classes her students are enrolled in, and any supplies fees which are associated with the classes.\r\n\r\n\r\n###Models###\r\nHere are the models.  In the `user` model, we've got an `enum` for the user's role.  This is to set up our authorization with Pundit.  The authorization is fairly simple and in this case Pundit probably isn't necessary, but as the application grows it will make things easier.  There's one ActiveRecord method which retrieves all the `User.guardians` (i.e. not the admin or any other as-yet-to-be-created user role).  In the StudentClass model, we've got a couple helper methods and the `supplies_attributes=` method which allows for the creation of the nested resource, `supplies`.  More on that later.  I've included a few simple form validations, although they are by no means exhaustive. \r\n```\r\n##Devise User Model##\r\nclass User < ActiveRecord::Base\r\n  ## bunch of Devise stuff ....\r\n\r\n  enum role: [:normal, :admin]\r\n  has_many :students\r\n  has_many :student_classes, :through => :students\r\n  has_many :supplies, :through => :student_classes\r\n \r\n  def self.guardians\r\n    where(\"role = 0\")\r\n  end\r\n\r\nend\r\n\r\n## Student Model ##\r\nclass Student < ActiveRecord::Base\r\n  belongs_to :user\r\n  belongs_to :student_class\r\n  validates :name, presence: true\r\nend\r\n\r\n##StudentClass Model##\r\nclass StudentClass < ActiveRecord::Base\r\n  has_many :students\r\n  has_many :supplies, dependent: :destroy\r\n  accepts_nested_attributes_for :supplies\r\n  serialize :meets_on\r\n  validates :name, presence: true\r\n  validate :student_class_validator\r\n  before_validation do |model|\r\n    model.meets_on.reject!(&:blank?) if model.meets_on\r\n  end\r\n\r\n  def class_name\r\n    \"#{self.name} - ages #{min_age} to #{max_age}\"\r\n  end\r\n\r\n  def supplies_attributes=(attr)\r\n    self.save\r\n    attr.values.each do |supply|\r\n      s = self.supplies.find_or_create_by(name: supply[:name])\r\n      s.update(name: supply[:name], amount: supply[:amount], date_due: self.start_date)\r\n    end\r\n  end\r\n\r\n  def self.pretty_time(time)\r\n    time.strftime \"%l:%M %P\"\r\n  end\r\nend\r\n\r\n  def student_class_validator\r\n    if start_time > end_time\r\n      errors[:base] << \"Start time must be before end time\"\r\n    end\r\n    if min_age > max_age\r\n      errors[:base] << \"Min age must be less than or equal to max age\"\r\n    end\r\n    if start_date > end_date\r\n      errors[:base] << \"Start date must come before end date\"\r\n    end\r\n    if meets_on.length == 0\r\n      errors[:base] << \"Must choose at least one day of the week\"\r\n    end\r\n  end\r\n\r\n##Supply Model##\r\nclass Supply < ActiveRecord::Base\r\n  belongs_to :student_class\r\nend\r\n```\r\n\r\n###Routing###\r\nThe model name `StudentClass` is a little clunky, but of course the word \"class\" is a reserved one in Ruby.  I kept the clunky model name and changed the path to `/classes` in the router. While nested resources aren't a necessity, they do make for a neater appearance in your urls.  In this case, we want to be able to go to `host/classes/2/students`, for example, to see the list of students in class number two.  Things could be made a bit prettier by slugifying the class name, but that's left for another exercise.\r\n\r\nNote that in the nested resource routing, we're only nesting the `show` and `index` controller actions: no need to provide routes to `host/classes/3/students/4/edit`, for example.\r\n\r\nHere's `routes.rb`.\r\n```\r\nRails.application.routes.draw do\r\n\r\n  root 'static_pages#welcome'\r\n  get 'static_pages/about'\r\n  get 'static_pages/contact'\r\n\r\n  devise_for :users, :controllers => { :omniauth_callbacks => \"users/omniauth_callbacks\" }\r\n\r\n  resources :student_classes, path: :classes do\r\n    resources :students, only: [:show, :index]\r\n  end\r\n\r\n  resources :users\r\n  resources :students\r\n  resources :supplies\r\n\r\nend\r\n```\r\n###Forms###\r\nAdding the following gems to the `Gemfile` permitted the easy creation of nice-looking forms:\r\n```\r\ngem 'bootstrap-sass', '~> 3.3', '>= 3.3.6'\r\ngem 'bootstrap-datepicker-rails'\r\ngem 'bootstrap_form'\r\ngem 'devise-bootstrap-views'\r\n```\r\nHere's the form to create a new `student_class`:\r\n```\r\n<div class=\"container\">\r\n<div class=\"col-md-6\">\r\n  <% if @student_class.errors.any? %>\r\n    <div id=\"error_explanation\">\r\n      <h2>\r\n        <%= pluralize(@student_class.errors.count, \"Error\") %> prohibited this class from being saved:</h2>\r\n      <ul>\r\n      <% @student_class.errors.full_messages.each do |msg| %>\r\n        <li><%= msg %></li>\r\n      <% end %>\r\n      </ul>\r\n    </div>\r\n  <% end %>\r\n<%= bootstrap_form_for @student_class do |f| %>\r\n  <%= f.text_field :name %>\r\n  <%= f.select :min_age, options_for_select(1..20) %>\r\n  <%= f.select :max_age, options_for_select(1..20) %>\r\n  <%= f.select(:meets_on, [['Mondays'],\r\n                          ['Tuesdays'],\r\n                          ['Wednesdays'],\r\n                          ['Thursdays'],\r\n                          ['Fridays'],\r\n                          ['Saturdays'],\r\n                          ['Sundays']],\r\n                          {},\r\n                          { :multiple => true, :size => 7}\r\n              ) %>\r\n              <%= f.time_select :start_time, \r\n                  :combined => true,\r\n                  :default => Time.now.change(:hour => 8, :min => 00),\r\n                  :minute_interval => 15,\r\n                  :time_separator => \"\",\r\n                  :start_hour => 6,\r\n                  :start_minute => 30,\r\n                  :end_hour => 20,\r\n                  :end_minute => 00,\r\n                  :ignore_date => true\r\n              %>\r\n            <%= f.time_select :end_time, \r\n                  :combined => true,\r\n                  :default => Time.now.change(:hour => 14, :min => 00),\r\n                  :minute_interval => 15,\r\n                  :time_separator => \"\",\r\n                  :start_hour => 6,\r\n                  :start_minute => 30,\r\n                  :end_hour => 20,\r\n                  :end_minute => 00,\r\n                  :ignore_date => true\r\n              %>\r\n  <%= f.text_field(:start_date, :data => {:provide => \"datepicker\"}, value: f.object.start_date.try(:strftime, \"%m/%d/%Y\"))%>\r\n  <%= f.text_field(:end_date, :data => {:provide => \"datepicker\"}, value: f.object.end_date.try(:strftime, \"%m/%d/%Y\"))%>\r\n  <p>Supplies:</p>\r\n  <%= f.fields_for :supplies do |supply| %>\r\n    <%= supply.text_field :name %>\r\n    <%= supply.text_field :amount %>\r\n  <% end %>\r\n  <%= f.submit %>\r\n<% end %>\r\n</div>\r\n</div>\r\n```\r\nIn the `time_select`s, I'm taking advantage of the gem `combined_time_select`, which is handy for creating a simple time picker in forms.  It should be noted that a certain amount of string wrangling and conversion is necessary when validating dates.  To ensure that, for example, the start date of a class must be earlier than the end date, one must convert those strings into `Date` objects before saving in the database, and convert them back into user-friendly strings when displaying the information in the browser.\r\n\r\nNote the creation of the `supplies` resource is nested within the form, allowing the creation (or editing) of supplies when creating (or editing) classes.  The nested form depends on a method in the `StudentClass` called `supplies_attributes=`.  If the object `respond_to? supplies_attributes=', The form_for helper will wrap the data from the nested form into a hash object called `supplies_attributes`.  To finalize this functionality, `supplies_attributes: [:name, :amount]` is added to the permitted params method in `student_classes_controller.rb`\r\n\r\n###Authorization with Pundit##\r\nPundit is a great tool for managing authorization.  In this simple application, the permission's aren't complicated: the Admin can CRUD all objects, while the basic user can only affect her own objects.  Here's an example, the `StudentPolicy`:\r\n```\r\nclass StudentPolicy < ApplicationPolicy\r\n\r\n  def create?\r\n    user.admin? || record.try(:user_id) == user.id\r\n  end\r\n\r\n  def edit?\r\n    user.admin? || record.try(:user_id) == user.id\r\n  end\r\n\r\n  def update?\r\n    user.admin? || record.try(:user_id) == user.id\r\n  end\r\n\r\n  def destroy?\r\n    user.admin? || record.try(:user_id) == user.id\r\n  end\r\n\r\nend\r\n```\r\nHere's an example of this policy in action, in `students#update`:\r\n```\r\n  def update\r\n    @student = Student.find(params[:id])\r\n    authorize @student\r\n    @student.update_attributes(student_params)\r\n    redirect_to @student\r\n  end\r\n```\r\nWe find the student through the `id` parameter, and authorize.  If `user.admin?`, we allow the update to go forward.  Otherwise, they get bumped to the `unauthorized` method in `ApplicationController`:\r\n```\r\n#application_controller.rb\r\n  def unauthorized(exception)\r\n    flash[:error] = \"Access Denied.\"\r\n    redirect_to(request.referrer || user_path(current_user))\r\n  end\r\nend\r\n```\r\nWhile it takes a few minutes of setup time, employing Pundit helps you clean up your controller code by abstracting away the logic to determine what the user's role is and if she should be permitted to execute the requested action.\r\n\r\n###Wrapping Up###\r\nWhile a lot of the focus is placed on large-scale enterprise software development, it's important to recognize the utility that Rails provides a developer for producing useful tools for small organizations. This application could easily develop into a valuable service for a school or organization by expanding its functionality to include the posting of schedules, newsletters, and accepting and scheduling recurring payments.  The inclusion of an authorization scheme like Pundit, along with an authentication system like Devise and OAuth will ensure that data will be kept safe and the site can be easily administered by the end user.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}